# cs-320-portfolio
CS 320: Software Testing, Automation, and Quality Assurance Portfolio
Reflection
Throughout Projects One and Two, I gained hands-on experience implementing and testing software components designed to meet specific user and system requirements. By creating classes such as Contact, Task, and Appointment, and implementing service layers to manage their lifecycle, I learned how to structure code that is modular, reusable, and maintainable. Writing unit tests using JUnit allowed me to validate expected behavior, detect defects early, and improve the reliability of the application.

How can I ensure that my code, program, or software is functional and secure?
Software becomes functional and secure through a combination of careful planning, defensive programming, validation rules, and consistent testing. In these projects, I used input validation to prevent improper data from entering the system, enforced constraints such as character length limits, and ensured objects could not be created with null values. Unit tests provided constant feedback by revealing edge cases, unexpected behaviors, and opportunities for refactoring. 

How do I interpret user needs and incorporate them into a program?
Interpreting user needs starts with examining the requirements and determining what actions or tasks users must perform. In these projects, I implemented features such as adding, updating, and deleting contacts, tasks, and appointments based on explicit acceptance criteria. By translating user stories into methods and validation rules, I connected what users expect with how the program behaves. Prioritizing clarity, simplicity, and data validation helps ensure that the software aligns with user goals and performs reliably.

How do I approach designing software?
I approach software design by breaking down requirements into smaller, logical components and considering how classes interact with each other. For these projects, I used object-oriented principles to create separate classes for data storage and service management, promoting clean organization and modularity. Writing tests early guided my implementation decisions and helped confirm correctness along the way. This test-driven mindset encouraged incremental development, reduced errors, and supported more maintainable code in the long term.
Overall, these projects strengthened my understanding of software testing, automation, quality assurance, and object-oriented design. They demonstrated how structured testing and thoughtful design contribute to building reliable and secure applications. Maintaining these examples in my portfolio will help me reference my problem-solving skills and my ability to apply real-world development practices.

